diff --git a/alexa-skill-smarthome/src/alexa_device.py b/alexa-skill-smarthome/src/alexa_device.py
index 1a14490..2d23039 100755
--- a/alexa-skill-smarthome/src/alexa_device.py
+++ b/alexa-skill-smarthome/src/alexa_device.py
@@ -18,7 +18,13 @@ CONTROLLER_MAPPING = {
     "TemperatureSensor": TemperatureSensor,
     "RollershutterController": RollershutterController,
     "ColorController": ColorController,
-    "ColorTemperatureController": ColorTemperatureController
+    "ColorTemperatureController": ColorTemperatureController,
+    "MotionSensor": MotionSensor,
+    "ContactSensor": ContactSensor,
+    "HumiditySensor": HumiditySensor,
+    "ThermostatController": ThermostatController,
+    "StepSpeakerController": StepSpeakerController,
+    "SceneController": SceneController
 }
 
 class AlexaDevice:
@@ -136,41 +142,33 @@ class AlexaDevice:
         }
 
     def execute_directive(self, directive):
-        """
-        Sucht den passenden Controller und lässt ihn den Befehl
-        in Hardware-Daten (MQTT) übersetzen.
-        """
         header = directive.get('header', {})
         payload = directive.get('payload', {})
         namespace = header.get('namespace')
         name = header.get('name')
 
-        # Den Controller finden, der für diesen Namespace zuständig ist
-        # Wir suchen in der Liste der Klassen-Referenzen, die wir in __init__ gesammelt haben
         target_controller = next((c for c in self.controllers if c.namespace == namespace), None)
 
         if target_controller:
-            # Den Controller bitten, den Befehl zu übersetzen
-            mqtt_data = target_controller.handle_directive(name, payload)
-            
-            # WICHTIG: Den internen State des Objekts sofort aktualisieren!
-            # So enthält die darauf folgende Alexa-Response direkt die neuen Werte.
-            if mqtt_data:
-                if isinstance(self.raw_state, dict):
-                    self.raw_state.update(mqtt_data)
-                else:
-                    # Falls raw_state ein String war (z.B. nur "ON"), 
-                    # wandeln wir ihn jetzt in ein sauberes Dict um.
-                    self.raw_state = mqtt_data
-            
-            return mqtt_data
-        
+            # Der Controller liefert jetzt beide Welten zurück
+            result = target_controller.handle_directive(name, payload, current_state=self.raw_state)
+
+            if result:
+                # 1. Speichern im Alexa-Format (DynamoDB)
+                alexa_data = result.get("alexa")
+                if alexa_data:
+                    self.raw_state.update(alexa_data)
+                    self.update_db()
+
+                # 2. Rückgabe des OpenHAB-Formats für den Lambda-Handler
+                return result.get("openhab")
+
         return None
-        
+
+
     def update_db(self):
         """Schreibt den aktuellen raw_state zurück in die DynamoDB."""
-        import boto3
-        
+
         # Nutze die Umgebungsvariable oder einen Standardnamen
         table_name = os.environ.get('DDB_TABLE', 'smarthome_devices')
         region = os.environ.get('AWS_DEFAULT_REGION', 'eu-west-1') # Deine Region!
diff --git a/alexa-skill-smarthome/src/controllers/__init__.py b/alexa-skill-smarthome/src/controllers/__init__.py
index ef6d28d..82953fa 100755
--- a/alexa-skill-smarthome/src/controllers/__init__.py
+++ b/alexa-skill-smarthome/src/controllers/__init__.py
@@ -7,6 +7,12 @@ from .temperature_sensor import TemperatureSensor
 from .rollershutter_controller import RollershutterController
 from .color_controller import ColorController
 from .color_temperature_controller  import ColorTemperatureController
+from .contact_sensor import ContactSensor
+from humidity_sensor import HumiditySensor
+from motion_sensor import MotionSensor
+from scene_controller import SceneController
+from step_speaker_controller import StepSpeakerController
+from thermostat_controller import ThermostatController
 
 # Optional: Eine Liste aller verfügbaren Controller für dynamische Checks
 __all__ = [
@@ -16,5 +22,11 @@ __all__ = [
     'TemperatureSensor',
     'RollershutterController',
     "ColorController",
-    "ColorTemperatureController"
+    "ColorTemperatureController",
+    "ContactSensor",
+    "HumiditySensor",
+    "MotionSensor",
+    "SceneController",
+    "StepSpeakerController",
+    "ThermostatController"
 ]
\ No newline at end of file
diff --git a/alexa-skill-smarthome/src/controllers/alexa_controller.py b/alexa-skill-smarthome/src/controllers/alexa_controller.py
index 037efa7..50e5507 100755
--- a/alexa-skill-smarthome/src/controllers/alexa_controller.py
+++ b/alexa-skill-smarthome/src/controllers/alexa_controller.py
@@ -21,11 +21,11 @@ class AlexaController(ABC):
         pass
 
     @staticmethod
-    def handle_directive(name, payload):
+    def handle_directive(name, payload, current_state):
         """Verarbeitet eine Direktive"""
         return {}
 
     @staticmethod
     def handle_update(update_dict):
         """Übersetzt Hardware-Status (z.B. von OpenHAB) -> Datenbank-Status."""
-        return {}
\ No newline at end of file
+        return {}
diff --git a/alexa-skill-smarthome/src/controllers/brightness_controller.py b/alexa-skill-smarthome/src/controllers/brightness_controller.py
index 65bfb30..3c8cb47 100755
--- a/alexa-skill-smarthome/src/controllers/brightness_controller.py
+++ b/alexa-skill-smarthome/src/controllers/brightness_controller.py
@@ -1,7 +1,11 @@
 # controllers/brightness_controller.py
 
+import logging
 from .alexa_controller import AlexaController
 
+logger = logging.getLogger(__name__)
+
+
 class BrightnessController(AlexaController):
     namespace = "Alexa.BrightnessController"
 
@@ -20,37 +24,43 @@ class BrightnessController(AlexaController):
 
     @staticmethod
     def get_properties(state_dict):
-        # Wir erwarten in state_dict['brightness'] einen Wert zwischen 0 und 100.
-        # Falls der Wert fehlt, setzen wir ihn standardmäßig auf 0.
+        # Alexa erwartet einen Integer zwischen 0 und 100
         value = state_dict.get('brightness', 0)
-        
-        # Sicherstellen, dass der Wert ein Integer ist (falls er als String aus der DB kommt)
         try:
-            value = int(value)
+            formatted_value = int(value)
         except (ValueError, TypeError):
-            value = 0
+            formatted_value = 0
 
         return [{
             "namespace": "Alexa.BrightnessController",
             "name": "brightness",
-            "value": value
+            "value": formatted_value
         }]
 
+
     @staticmethod
-    def handle_directive(name, payload):
-        # RICHTUNG: ALEXA -> MQTT/DB
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"BrightnessController: Handling directive '{name}' with payload: {payload}")
+        new_brightness = None
+
+        # 1. Absolute Steuerung
         if name == "SetBrightness":
-            # Alexa schickt: {"brightness": 75}
-            brightness_value = payload.get('brightness', 0)
-            
-            # Wir geben das Dict zurück, das MQTT und den internen State aktualisiert
-            return {"brightness": brightness_value}
-        
+            new_brightness = int(payload.get('brightness', 0))
+
+        # 2. Relative Steuerung (Delta)
         elif name == "AdjustBrightness":
-            # Optional: Alexa schickt ein Delta, z.B. {"brightnessDelta": -10}
-            # Da wir im Controller aber keinen Zugriff auf den aktuellen DB-Stand haben,
-            # überlassen wir die Berechnung meistens der Logik im AlexaDevice
-            # oder wir ignorieren es, da Alexa oft selbst den neuen absoluten Wert berechnet.
+            current_val = current_state.get('brightness', 50) if current_state else 50
+            delta = payload.get('brightnessDelta', 0)
+            new_brightness = max(0, min(100, int(current_val + delta)))
+            logger.info(f"Brightness adjustment: {current_val}% -> {new_brightness}%")
+
+        else:
             pass
-            
+
+        if new_brightness is not None:
+            return {
+                "alexa": {"brightness": new_brightness},  # Für DynamoDB
+                "openhab": new_brightness  # Für MQTT/OpenHAB
+            }
+
         return {}
\ No newline at end of file
diff --git a/alexa-skill-smarthome/src/controllers/color_controller.py b/alexa-skill-smarthome/src/controllers/color_controller.py
index 67b4c49..1160b6a 100755
--- a/alexa-skill-smarthome/src/controllers/color_controller.py
+++ b/alexa-skill-smarthome/src/controllers/color_controller.py
@@ -58,26 +58,58 @@ class ColorController(AlexaController):
         }]
 
     @staticmethod
-    def handle_directive(name, payload):
-        logger.info(f"ColorController: Handling directive '{name}' with payload: {payload}")
-
-        # Standard-Fallback bei Fehlern: Schwarz (Aus)
-        fallback_color = {"hue": 0.0, "saturation": 0.0, "brightness": 0.0}
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"ColorController: Handling '{name}'")
 
         if name == "SetColor":
-            color_value = payload.get('color')
-
-            if not color_value or not isinstance(color_value, dict):
-                logger.error(f"ColorController: Received invalid 'color' payload in SetColor: {color_value}")
-                return {"color": fallback_color}
-
-            # Prüfung auf korrekte Struktur im Payload von Alexa
-            if all(k in color_value for k in ("hue", "saturation", "brightness")):
-                logger.info(f"ColorController: Successfully extracted color: {color_value}")
-                return {"color": color_value}
-            else:
-                logger.error(f"ColorController: Incomplete color object in payload: {color_value}")
-                return {"color": fallback_color}
-
-        logger.warning(f"ColorController: Directive '{name}' not supported by this controller.")
-        return {}
\ No newline at end of file
+            new_color = payload.get('color')
+
+            # Validierung des Alexa-Payloads
+            if not new_color or not all(k in new_color for k in ("hue", "saturation", "brightness")):
+                logger.error(f"ColorController: Invalid color payload: {new_color}")
+                return {}
+
+            # 1. Alexa-Format (für DynamoDB)
+            alexa_state = {"color": new_color}
+
+            # 2. OpenHAB-Format (Konvertierung zu H,S,V String)
+            # OpenHAB erwartet oft: "hue,saturation,brightness"
+            # Alexa liefert Floats, OpenHAB bevorzugt oft gerundete Werte oder Floats als String
+            h = new_color['hue']
+            s = new_color['saturation'] * 100  # Alexa: 0.0-1.0 -> OpenHAB: 0-100
+            b = new_color['brightness'] * 100  # Alexa: 0.0-1.0 -> OpenHAB: 0-100
+
+            openhab_command = f"{h:.1f},{s:.1f},{b:.1f}"
+
+            logger.info(f"ColorController: Alexa color {new_color} mapped to OpenHAB: {openhab_command}")
+
+            return {
+                "alexa": alexa_state,
+                "openhab": openhab_command
+            }
+
+        logger.warning(f"ColorController: Directive '{name}' not supported.")
+        return {}
+
+    @staticmethod
+    def handle_directive(name, payload, current_state=None):
+        if name != "SetColor":
+            logger.warning(f"ColorController: Directive '{name}' not supported.")
+            return {}
+
+        new_color = payload.get('color')
+
+        # VALIDIERUNG: Wenn der Payload Schrott ist, brechen wir sofort ab
+        if not new_color or not all(k in new_color for k in ("hue", "saturation", "brightness")):
+            logger.error(f"ColorController: Invalid color payload, skipping update: {new_color}")
+            return {}  # Kein alexa/openhab Key -> Keine Aktion in execute_directive
+
+        # Wenn wir hier sind, ist der Payload sicher
+        h = new_color['hue']
+        s = new_color['saturation'] * 100
+        b = new_color['brightness'] * 100
+
+        return {
+            "alexa": {"color": new_color},
+            "openhab": f"{h:.1f},{s:.1f},{b:.1f}"
+        }
\ No newline at end of file
diff --git a/alexa-skill-smarthome/src/controllers/color_temperature_controller.py b/alexa-skill-smarthome/src/controllers/color_temperature_controller.py
index 06b2266..2c8c87d 100755
--- a/alexa-skill-smarthome/src/controllers/color_temperature_controller.py
+++ b/alexa-skill-smarthome/src/controllers/color_temperature_controller.py
@@ -49,29 +49,40 @@ class ColorTemperatureController(AlexaController):
         }]
 
     @staticmethod
-    def handle_directive(name, payload):
-        logger.info(f"ColorTemperatureController: Handling directive '{name}' with payload: {payload}")
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"ColorTemperatureController: Handling '{name}'")
 
-        # Standard-Fallback bei Fehlern: Warmweiß
         fallback_temp = 2700
+        new_temp = None
 
+        # --- Absolute Steuerung ---
         if name == "SetColorTemperature":
-            temp_value = payload.get('colorTemperatureInKelvin')
-
-            if temp_value is not None:
-                logger.info(f"ColorTemperatureController: SetColorTemperature to {temp_value}K")
-                return {"colorTemperatureInKelvin": int(temp_value)}
-            else:
-                logger.error("ColorTemperatureController: Missing temperature value in SetColorTemperature payload.")
-                return {"colorTemperatureInKelvin": fallback_temp}
+            # Wir nehmen den Wert nur an, wenn er wirklich im Payload ist
+            new_temp = payload.get('colorTemperatureInKelvin')
+            if new_temp is None:
+                logger.error("ColorTemperatureController: No value in SetColorTemperature")
+                return {}  # Abbruch ohne Aktion
 
+        # --- Relative Steuerung ---
         elif name in ("IncreaseColorTemperature", "DecreaseColorTemperature"):
-            # Diese Direktiven werden gesendet bei "Alexa, mach das Licht kühler/wärmer"
-            # Da wir hier keinen direkten Zugriff auf den aktuellen State haben ohne DB-Lookup,
-            # wird oft empfohlen, dies im übergeordneten Handler zu lösen oder hier einen
-            # relativen Sprung (z.B. +/- 500K) zurückzugeben, falls dein System das kann.
-            logger.warning(f"ColorTemperatureController: Relative change '{name}' requested but not implemented here.")
-            return {}
+            # Aktuellen Wert ermitteln
+            current_val = current_state.get('colorTemperatureInKelvin',
+                                            fallback_temp) if current_state else fallback_temp
+
+            # Delta berechnen
+            delta = 500 if name == "IncreaseColorTemperature" else -500
+            new_temp = int(current_val + delta)
+
+            # Grenzen einhalten
+            new_temp = max(1000, min(10000, new_temp))
+            logger.info(f"ColorTemperature adjustment: {current_val}K -> {new_temp}K")
+
+        # --- Ergebnis verarbeiten ---
+        if new_temp is not None:
+            return {
+                "alexa": {"colorTemperatureInKelvin": int(new_temp)},
+                "openhab": int(new_temp)  # Hier könntest du 1000000 / new_temp rechnen, falls du Mireds brauchst
+            }
 
         logger.warning(f"ColorTemperatureController: Directive '{name}' not supported.")
         return {}
\ No newline at end of file
diff --git a/alexa-skill-smarthome/src/controllers/power_controller.py b/alexa-skill-smarthome/src/controllers/power_controller.py
index e83c884..9112f87 100755
--- a/alexa-skill-smarthome/src/controllers/power_controller.py
+++ b/alexa-skill-smarthome/src/controllers/power_controller.py
@@ -1,7 +1,11 @@
 # controllers/power_controller.py
 
+import logging
 from .alexa_controller import AlexaController
 
+# Logger konfigurieren
+logger = logging.getLogger(__name__)
+
 class PowerController(AlexaController):
     namespace = "Alexa.PowerController"
 
@@ -29,7 +33,16 @@ class PowerController(AlexaController):
         }]
 
     @staticmethod
-    def handle_directive(name, payload):
-        # name ist "TurnOn" oder "TurnOff"
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"PowerController: Handling '{name}'")
+
+        if name not in ("TurnOn", "TurnOff"):
+            logger.warning(f"PowerController: Directive '{name}' not supported.")
+            return {}
+
         value = "ON" if name == "TurnOn" else "OFF"
-        return {"power": value}
+
+        return {
+            "alexa": {"power": value},
+            "openhab": value
+        }
diff --git a/alexa-skill-smarthome/src/controllers/rollershutter_controller.py b/alexa-skill-smarthome/src/controllers/rollershutter_controller.py
index 109d960..5d8b857 100755
--- a/alexa-skill-smarthome/src/controllers/rollershutter_controller.py
+++ b/alexa-skill-smarthome/src/controllers/rollershutter_controller.py
@@ -1,7 +1,11 @@
 # controllers/rollershutter_controller.py
 
+import logging
 from .alexa_controller import AlexaController
 
+# Logger konfigurieren
+logger = logging.getLogger(__name__)
+
 
 class RollershutterController(AlexaController):
     namespace = "Alexa.ModeController"
@@ -118,22 +122,28 @@ class RollershutterController(AlexaController):
         ]
 
     @staticmethod
-    def handle_directive(name, payload):
-        # name ist "SetMode", payload['mode'] ist "Position.Up"
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"Rollershutter: Handling '{name}'")
+
         if name == "SetMode":
-            mode_value = payload["mode"].split(".")[-1]  # "Up", "Down", "Stopped"
-            return {"mode": mode_value.upper()}
-        return {}
+            # 1. Wir behalten den VOLLEN Namen für die Datenbank/Alexa (Status-Reporting)
+            # Alexa schickt z.B. "Position.Up"
+            full_mode = payload.get("mode")
 
-    @staticmethod
-    def handle_update(update_dict):
-        # Hardware (OpenHAB) -> DB
-        # Angenommen OpenHAB schickt: {"state": "OPEN"} oder {"state": "CLOSED"}
-        oh_state = update_dict.get("state")
-        if oh_state == "OPEN":
-            return {"mode": "Position.Up"}
-        elif oh_state == "CLOSED":
-            return {"mode": "Position.Down"}
-        elif oh_state == "MOVE":  # Nur ein Beispiel
-            return {"mode": "Position.Stopped"}
+            # 2. Wir extrahieren den Befehl für OpenHAB
+            # Wir mappen die Alexa-Werte auf die OpenHAB-Strings
+            oh_command = "STOP"
+            if "Up" in full_mode:
+                oh_command = "UP"
+            elif "Down" in full_mode:
+                oh_command = "DOWN"
+            elif "Stopped" in full_mode:
+                oh_command = "STOP"
+
+            return {
+                "alexa": {"mode": full_mode},  # Speichert "Position.Up" in DynamoDB
+                "openhab": oh_command  # Sendet "UP" via MQTT
+            }
+
+        logger.warning(f"Rollershutter: Directive '{name}' not supported.")
         return {}
diff --git a/alexa-skill-smarthome/src/controllers/speaker_controller.py b/alexa-skill-smarthome/src/controllers/speaker_controller.py
index c6e48d0..c7e5eb8 100755
--- a/alexa-skill-smarthome/src/controllers/speaker_controller.py
+++ b/alexa-skill-smarthome/src/controllers/speaker_controller.py
@@ -1,7 +1,10 @@
 # controllers/speaker_controller.py
 
+import logging
 from .alexa_controller import AlexaController
 
+logger = logging.getLogger(__name__)
+
 class SpeakerController(AlexaController):
     namespace = "Alexa.Speaker"
 
@@ -32,25 +35,40 @@ class SpeakerController(AlexaController):
         ]
 
     @staticmethod
-    def handle_directive(name, payload):
-        # RICHTUNG: ALEXA -> MQTT/DB
-        
+    def handle_directive(name, payload, current_state=None):
+        logger.info(f"SpeakerController: Handling '{name}'")
+
+        new_volume = None
+
+        # 1. Absolute Lautstärke: "Stelle Lautstärke auf 30"
         if name == "SetVolume":
-            # Alexa schickt: {"volume": 30}
-            volume = payload.get('volume', 20)
-            return {"volume": volume}
-            
-        elif name == "SetMute":
-            # Alexa schickt: {"mute": true}
-            mute_state = payload.get('mute', False)
-            return {"muted": mute_state}
-            
+            new_volume = int(payload.get('volume', 0))
+
+        # 2. Relative Lautstärke: "Mach lauter / leiser"
         elif name == "AdjustVolume":
-            # Alexa schickt ein Delta: {"volume": -10, "volumeDefault": False}
-            # Da wir hier keinen Zugriff auf den DB-Stand haben, geben wir das Delta weiter.
-            # Dein MQTT-Handler oder das Device muss dann: current_vol + delta rechnen.
+            # Wir holen den aktuellen Wert (Standard 10, falls leer)
+            current_val = current_state.get('volume', 10) if current_state else 10
+
+            # volumeDelta ist positiv (lauter) oder negativ (leiser)
             delta = payload.get('volume', 0)
-            return {"volume_delta": delta}
-            
-        return {}
 
+            # Berechnung mit Grenzen 0 bis 100
+            new_volume = max(0, min(100, int(current_val + delta)))
+            logger.info(f"Volume adjustment: {current_val} -> {new_volume} (Delta: {delta})")
+
+        # 3. Stummschalten: "Stumm" / "Ton an"
+        elif name == "SetMute":
+            mute_state = payload.get('mute', False)
+            return {
+                "alexa": {"mute": mute_state},
+                "openhab": "ON" if mute_state else "OFF"
+            }
+
+        if new_volume is not None:
+            return {
+                "alexa": {"volume": new_volume},
+                "openhab": new_volume
+            }
+
+        logger.warning(f"SpeakerController: Directive '{name}' not supported.")
+        return {}
\ No newline at end of file
diff --git a/alexa-skill-smarthome/src/controllers/temperature_sensor.py b/alexa-skill-smarthome/src/controllers/temperature_sensor.py
index 4237fd5..5ed88f1 100755
--- a/alexa-skill-smarthome/src/controllers/temperature_sensor.py
+++ b/alexa-skill-smarthome/src/controllers/temperature_sensor.py
@@ -38,4 +38,10 @@ class TemperatureSensor(AlexaController):
                 "value": temp_value,
                 "scale": "CELSIUS"  # Alexa unterstützt CELSIUS, FAHRENHEIT, KELVIN
             }
-        }]
\ No newline at end of file
+        }]
+
+    @staticmethod
+    def handle_directive(name, payload, current_state=None):
+        # MotionSensoren empfangen normalerweise keine Direktiven von Alexa,
+        # aber das Interface muss für den Discovery/Handler-Loop existieren.
+        return {}
\ No newline at end of file
